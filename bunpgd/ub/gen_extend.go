//go:build gen_extend

package main

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"reflect"
	"text/template"

	"github.com/uptrace/bun"
)

func main() {
	buf := new(bytes.Buffer)
	writeHead(buf)
	tpl.Execute(buf, map[string]string{"Query": "Select"})
	tpl.Execute(buf, map[string]string{"Query": "Update"})
	tpl.Execute(buf, map[string]string{"Query": "Insert"})
	tpl.Execute(buf, map[string]string{"Query": "Delete"})

	os.WriteFile("bun_gen_extend.go", buf.Bytes(), 0644)
}

func writeHead(w io.Writer) {
	_, _ = w.Write([]byte(fmt.Sprintf(`// Code generated by bunpgd/ub. DO NOT EDIT.
// versions: bun %s
// source: bunpgd/ub/gen_extend.go

package ub

import (
	"reflect"
	"strings"

	"github.com/uptrace/bun"
	"github.com/uptrace/bun/schema"
)
`, bun.Version())))
}

func getTypeMethod(rt reflect.Type) map[string]reflect.Method {
	m := make(map[string]reflect.Method)
	for i := 0; i < rt.NumMethod(); i++ {
		method := rt.Method(i)

		returnType := method.Type.Out(0)

		if rt == returnType {
			m[method.Name] = method
		}
	}
	return m
}

var tpl = template.Must(template.New("").Parse(`
func (x *{{.Query}}) WhereIn(key string, val any) *{{.Query}} {
	if val == nil {
		return x
	}

	rv := reflect.ValueOf(val)
	if rv.Len() == 1 {
		return x.Where("? = ?", bun.Ident(key), rv.Index(0).Interface())
	}
	return x.Where("? IN (?)", bun.Ident(key), schema.In(val))
}

func (x *{{.Query}}) WhereInX(key string, val any) *{{.Query}} {
	if val == nil {
		return x
	}

	rv := reflect.ValueOf(val)
	if rv.Len() == 1 {
		return x.Where(key+" = ?", rv.Index(0).Interface())
	}
	return x.Where(key+" IN (?)", schema.In(val))
}

func (x *{{.Query}}) WhereEqOrLike(key string, val string) *{{.Query}} {
	if val == "" || val == "*" {
		return x
	}

	if !strings.ContainsAny(val, "*") {
		return x.Where("? = ?", bun.Ident(key), val)
	}
	return x.Where("? LIKE ?", bun.Ident(key), strings.ReplaceAll(val, "*", "%"))
}

func (x *{{.Query}}) WhereOrEqOrLike(key string, val []string) *{{.Query}} {
	var precise []string

	for i := range val {
		if val[i] == "" || val[i] == "*" {
		} else if strings.ContainsAny(val[i], "*") {
			x.Where("? LIKE ?", bun.Ident(key), strings.ReplaceAll(val[i], "*", "%"))
		} else {
			precise = append(precise, val[i])
		}
	}

	switch len(precise) {
	case 0:
	case 1:
		x.WhereOr("? = ?", bun.Ident(key), val[0])
	default:
		x.WhereOr("? IN (?)", bun.Ident(key), bun.In(val))
	}
	return x
}
`))
