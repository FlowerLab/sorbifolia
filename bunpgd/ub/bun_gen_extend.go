// Code generated by bunpgd/ub. DO NOT EDIT.
// versions: bun 1.2.3
// source: bunpgd/ub/gen_extend.go

package ub

import (
	"reflect"
	"strings"

	"github.com/uptrace/bun"
	"github.com/uptrace/bun/schema"
)

func (x *Select) WhereIn(key string, val any) *Select {
	if val == nil {
		return x
	}

	rv := reflect.ValueOf(val)
	if rv.Len() == 1 {
		return x.Where("? = ?", bun.Ident(key), rv.Index(0).Interface())
	}
	return x.Where("? IN (?)", bun.Ident(key), schema.In(val))
}

func (x *Select) WhereInX(key string, val any) *Select {
	if val == nil {
		return x
	}

	rv := reflect.ValueOf(val)
	if rv.Len() == 1 {
		return x.Where(key+" = ?", rv.Index(0).Interface())
	}
	return x.Where(key+" IN (?)", schema.In(val))
}

func (x *Select) WhereEqOrLike(key string, val string) *Select {
	if val == "" || val == "*" {
		return x
	}

	if !strings.ContainsAny(val, "*") {
		return x.Where("? = ?", bun.Ident(key), val)
	}
	return x.Where("? LIKE ?", bun.Ident(key), strings.ReplaceAll(val, "*", "%"))
}

func (x *Select) WhereOrEqOrLike(key string, val []string) *Select {
	var precise []string

	for i := range val {
		if val[i] == "" || val[i] == "*" {
		} else if strings.ContainsAny(val[i], "*") {
			x.Where("? LIKE ?", bun.Ident(key), strings.ReplaceAll(val[i], "*", "%"))
		} else {
			precise = append(precise, val[i])
		}
	}

	switch len(precise) {
	case 0:
	case 1:
		x.WhereOr("? = ?", bun.Ident(key), val[0])
	default:
		x.WhereOr("? IN (?)", bun.Ident(key), bun.In(val))
	}
	return x
}

func (x *Update) WhereIn(key string, val any) *Update {
	if val == nil {
		return x
	}

	rv := reflect.ValueOf(val)
	if rv.Len() == 1 {
		return x.Where("? = ?", bun.Ident(key), rv.Index(0).Interface())
	}
	return x.Where("? IN (?)", bun.Ident(key), schema.In(val))
}

func (x *Update) WhereInX(key string, val any) *Update {
	if val == nil {
		return x
	}

	rv := reflect.ValueOf(val)
	if rv.Len() == 1 {
		return x.Where(key+" = ?", rv.Index(0).Interface())
	}
	return x.Where(key+" IN (?)", schema.In(val))
}

func (x *Update) WhereEqOrLike(key string, val string) *Update {
	if val == "" || val == "*" {
		return x
	}

	if !strings.ContainsAny(val, "*") {
		return x.Where("? = ?", bun.Ident(key), val)
	}
	return x.Where("? LIKE ?", bun.Ident(key), strings.ReplaceAll(val, "*", "%"))
}

func (x *Update) WhereOrEqOrLike(key string, val []string) *Update {
	var precise []string

	for i := range val {
		if val[i] == "" || val[i] == "*" {
		} else if strings.ContainsAny(val[i], "*") {
			x.Where("? LIKE ?", bun.Ident(key), strings.ReplaceAll(val[i], "*", "%"))
		} else {
			precise = append(precise, val[i])
		}
	}

	switch len(precise) {
	case 0:
	case 1:
		x.WhereOr("? = ?", bun.Ident(key), val[0])
	default:
		x.WhereOr("? IN (?)", bun.Ident(key), bun.In(val))
	}
	return x
}

func (x *Insert) WhereIn(key string, val any) *Insert {
	if val == nil {
		return x
	}

	rv := reflect.ValueOf(val)
	if rv.Len() == 1 {
		return x.Where("? = ?", bun.Ident(key), rv.Index(0).Interface())
	}
	return x.Where("? IN (?)", bun.Ident(key), schema.In(val))
}

func (x *Insert) WhereInX(key string, val any) *Insert {
	if val == nil {
		return x
	}

	rv := reflect.ValueOf(val)
	if rv.Len() == 1 {
		return x.Where(key+" = ?", rv.Index(0).Interface())
	}
	return x.Where(key+" IN (?)", schema.In(val))
}

func (x *Insert) WhereEqOrLike(key string, val string) *Insert {
	if val == "" || val == "*" {
		return x
	}

	if !strings.ContainsAny(val, "*") {
		return x.Where("? = ?", bun.Ident(key), val)
	}
	return x.Where("? LIKE ?", bun.Ident(key), strings.ReplaceAll(val, "*", "%"))
}

func (x *Insert) WhereOrEqOrLike(key string, val []string) *Insert {
	var precise []string

	for i := range val {
		if val[i] == "" || val[i] == "*" {
		} else if strings.ContainsAny(val[i], "*") {
			x.Where("? LIKE ?", bun.Ident(key), strings.ReplaceAll(val[i], "*", "%"))
		} else {
			precise = append(precise, val[i])
		}
	}

	switch len(precise) {
	case 0:
	case 1:
		x.WhereOr("? = ?", bun.Ident(key), val[0])
	default:
		x.WhereOr("? IN (?)", bun.Ident(key), bun.In(val))
	}
	return x
}

func (x *Delete) WhereIn(key string, val any) *Delete {
	if val == nil {
		return x
	}

	rv := reflect.ValueOf(val)
	if rv.Len() == 1 {
		return x.Where("? = ?", bun.Ident(key), rv.Index(0).Interface())
	}
	return x.Where("? IN (?)", bun.Ident(key), schema.In(val))
}

func (x *Delete) WhereInX(key string, val any) *Delete {
	if val == nil {
		return x
	}

	rv := reflect.ValueOf(val)
	if rv.Len() == 1 {
		return x.Where(key+" = ?", rv.Index(0).Interface())
	}
	return x.Where(key+" IN (?)", schema.In(val))
}

func (x *Delete) WhereEqOrLike(key string, val string) *Delete {
	if val == "" || val == "*" {
		return x
	}

	if !strings.ContainsAny(val, "*") {
		return x.Where("? = ?", bun.Ident(key), val)
	}
	return x.Where("? LIKE ?", bun.Ident(key), strings.ReplaceAll(val, "*", "%"))
}

func (x *Delete) WhereOrEqOrLike(key string, val []string) *Delete {
	var precise []string

	for i := range val {
		if val[i] == "" || val[i] == "*" {
		} else if strings.ContainsAny(val[i], "*") {
			x.Where("? LIKE ?", bun.Ident(key), strings.ReplaceAll(val[i], "*", "%"))
		} else {
			precise = append(precise, val[i])
		}
	}

	switch len(precise) {
	case 0:
	case 1:
		x.WhereOr("? = ?", bun.Ident(key), val[0])
	default:
		x.WhereOr("? IN (?)", bun.Ident(key), bun.In(val))
	}
	return x
}
